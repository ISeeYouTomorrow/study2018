1.缓存支撑高并发 ，缓存失效即可以同步数据库与缓存。
2.mysql数据库优化方式： 读写分离；分库分表；数据库集群。
3.缓存失效瞬间导致大量请求访问数据库，数据库连接（300-700）资源不足，导致请求拒绝。
4.jvm锁：synchorized Lock RetreentLock(互斥锁)
	多线程先从缓存获取数据->缓存没有则加锁->再从缓存获取数据->从数据库获取数据，放入缓存->解锁，其他线程从缓存获取数据。

5.分布式锁：zookeeper锁 redis锁

6.volatile 多线程并发时保证可见性，但是不保证同步性，可以用于一个修改多个读取的场景。必须自己做同步控制。voliate 一般在并发环境下使用，不能保证线程安全，只能保证多线程读取最新的，再多线程环境需要使用同步机制保证写的安全性

7.分布式系统：一件事情由多个系统协同完成；集群：多个机器完成同一件工作。微服务即一种分布式架构方式，核心是去中心化。RPC核心是客户端和服务端的协议/寻址/序列化(可存储或传输的数据json/xml/二进制数据)反序列化（内存数据）。序列化数据便于压缩存储/网络传输。
8.分布式系统的事务处理：ACID(原子性 一致性 隔离性 持久性)（Automic Consistency Isolation Durability）
CAP(一致性Consistency 可用性Availability 容错性Partition tolerance)
例如：
	1XA协议: 数据库厂商上线JTA数据库事务（一个系统可以操作其他系统数据库）
	2后台任务定期校对数据(妥协方式，可能会有误差)
	3消息队列最终一致
	4 tcc(try confirm cancel)机制
分布式特点：任务拆分 节点分工 分布式解决的是高可用，高并发问题。
集群：解决高可用


9.Redis 核心：网络数据包	resp协议
10. OAuth(Open Authorization,开放授权)
11 mysql 索引 BTree树，普通索引 唯一索引(允许null) 主键索引（不允许null聚簇索引:相关数据存储位置接近），
组合索引（最左策略），覆盖索引(最快)，全文索引
BTree索引 Hash索引
12.nginx -t (启动)  nginx -s reload （配置生效重启）nginx -t stop (安全的关闭nginx) taskkill /im nginx.exe /f  (强制杀死)
13.  cd my-project
     npm install
     npm run dev

	 "dev": "node build/dev-server.js",

	 "build": "node build/build.js",
	 http://download.oracle.com/otn-pub/java/jdk/8u171-b11/512cd62ec5174c3487ac17c61aaa89e8/jdk-8u171-linux-x64.tar.gz
14.zookeeper 是一个针对分布式系统提供配置维护，名字服务，分布式同步，组服务等的可靠的协调系统。zookeeper可以集群复制，通过zab（zookeerper atomic broadcast）协议保持数据一致性。
	协议包括两个阶段：leader election 和Atomic Broadcast阶段。
15.
	vim - 创建文件 vim newfile
	vim - 光标移动	通过 ↑↓←→按键进行光标的移动。如果没有 ↑↓←→按键，可以通过 k上   h左   j下   l右  来进行移动。
	vim - 退出
		执行以下命令之前可以先按一下  Esc  键，以确保处于视图模式
		：命令严格区分大小写
		- 保存并退出       :wq + 回车键
		- 保存并退出       ZZ
		- 不保存退出       :q! +回车键

	vim - 删除
		在视图模式下删除当前光标处的文本      x键
		在视图模式下删除当前光标处的整行 dd
	vim - 编辑模式
		进入编辑模式 i键
		插入按a键
	vim - 撤销
		撤销上一次的操作，等同于Ctrl + z u键
		重做 Ctrl + r
	vim - 文本替换
		%s/被替换的文本/替换成的文本，比如%s/o/+++会把所有的o替换成+++。如图所示
	vim - 文本搜索
		搜索 /欲搜索的文本，比如  /o 会搜索文本中所有的o，如下图
		找到文本后，通过n和N命令切换到上一个和下一个
	vim - 复制和粘贴
		复制光标处所在的行 yy 粘贴 p
16 jdk和zookeepe环境搭建
		#set java environment
		JAVA_HOME=/usr/java/jdk1.8.0_171
		JRE_HOME=/usr/java/jdk1.8.0_171/jre
		CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib
		PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin
		export JAVA_HOME JRE_HOME CLASS_PATH PATH


		#set zookeeper
		export ZOOKEEPER_INSTALL=/usr/zooKeeper/zookeeper
		export PATH=$PATH:$ZOOKEEPER_INSTALL/bin
17 aop:静态代理（aspect，修改java字节码，植入字节码方式）；动态代理：cglib/jdk proxy，在内存生成代理对象，包含被代理类的全部方法，在指定的位置执行代理。
18 Windows /bin/catalina.bat ;linux /bin/catalina.sh
19 参数描述符 Ljava/lang/String  [可达性分析法  引用计数法]
20 yum install nginx
   yum install java-1.8.0-openjdk.x86_64

21 +++++++++++++++++++++分布式系统架构+++++++++++++++++++++++
	大前端(h5浏览器/app/pc/物联网)
	CDN(内容分发网络):js/css/apk/png静态资源分发
   DNS(域名解析，负载均衡&高可用:一个域名对应多个ip);访问网址前向DNS服务器发送udp请求，获取对应ip地址。
   硬件负载均衡：(F5/redware)---软件负载均衡：nginx
   保障性能：
	   读多写少：缓存(redis memcache,Nosql)
	   写多读少：队列(kafka rabbitmq activemq)
	   限流（阻断用户操作：成本 能力）
    分布式系统管理：

	解耦：mq可以做远程调用事务处理,(生产者/消费者 ，分布式事务)
	配置中心：（disconf qconf diemond springcloud config）
	日志系统管理：(ELK:)日志收集汇总及索引
	系统监控：
		命令：linux free TOP命令
		链路监控：zabbix springcloud-zipkin/sleuth
		日志监控：elk
		代码监控：java metrics(形成图表)
	持续集成，自动化jenkins
	Docker+云计算，服务编排
	历史：代码编译-war包-tomcat解压缩-启动

	自动化部署：jenkins docker
	分布式系统应用架构:
	[h5 PC APP]---->F5/Redware----->nginx集群-------->分布式服务器(web服务器+web服务器+web服务器)------>多服务(分布式服务/微服务)------>基础组件(数据库、配置中心、缓存、消息队列、全文检索)------>数据库层(mysql/oracle/nosql)

	++++++++++++++++++++++++++++++++++++++++++++
	GCRoots对象：所有正在运行的线程的栈上的引用变量。所有全局变量，所有的ClassLoader。
	java虚拟机栈是线程私有的，生命周期与线程相爱难沟通。对应每个方法：局部变量/操作栈/动态链接/返回值。
	方法区：线程共享内存区域，类信息/常量/静态变量/即时编译的代码等。
	即时编译优化：
	1、-XX:-DisableExplicitGC，禁用了System.gc()的显示调用
	2、逃逸分析默认是启用的，-XX:+DoEscapeAnalysis。后续有三种优
		化会进行：栈内分配，同步消除，标量替换
	3、偏向锁，关闭： -XX:-UseBiasedLocking
	-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0
	4、指针压缩，-XX:+UseCompressedOops
	5、getter方法优化，-XX:UseFastAccessorMethods
	-------------------------------------
	内存优化策略：
	1、将新对象预留在年轻代，-XX:TargetSurvivorRatio=90
	2、让大对象进入年老代，-XX:PetenureSizeThreshold=1000000，1M
	3、设置对象进入年老代的年龄，-XX:MaxTenuringThreshold=31
	4、稳定的 Java 堆 ，Xmx与Xms相同
	5 、增大吞吐量提升系统性能， – X X : + U s e P a r a l l e l G C ，
	–XX:+UseParallelOldGC，–XX:ParallelGC-Threads（CPU核心数相等）
	6、使用非占有的垃圾回收器，–XX:+UseConcMarkSweepGC
	7. 设置tomcat内存优化（linux查看Tomcat配置：ps -ef | grep tomcat）
	linux :  /tomcat/catalina.sh 或者   /etc/tomcat/tomcat.conf: JAVA_OPTS="-server -Xms128m -Xmx128m -XX:PermSize=64M -XX:MaxPermSize=128M -XX:MaxNewSize=64M"
	windows:/tomcat/catalina.bat JAVA_OPTS="-server -Xms128m -Xmx128m -XX:PermSize=64M -XX:MaxPermSize=128M -XX:MaxNewSize=64M"
	8.jsp 进程查看：
	jps -m -l -v -q
	9 jstat 虚拟机内存统计信息：
	  jstat -class 1000(查看加载类数量及大小)
	  jstat -gc 1000（查看gc）
	  jstat -gcnew -gcold
	  jstat -options
	10 jmap java内存映像工具
	   jmap -heap 1000(进程内存信息)
	11 windows: tasklist | findstr java(windos == jps)
	   linux : top free   (jps ps -ef | grep tomcat）
	12 jmap
	    jmap -dump:live,format=b,file=heap 10052 ##(导出jvm内存信息)
	    jmap -histo 10052 ##查看jvm堆对象详细占用情况
	13 jinfo java配置信息工具
	   jinfo -flags 10052
	14 jconsole   图形化界面  jvisualvm 详细图形化分析工具
	  linux 需要xwindows工具
	15 jhat 虚拟机堆转储快照分析工具

	服务器：8 cup, 8G mem
    e.g.
    java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0
    调优方案：
    -Xmx5g：设置JVM最大可用内存为5G。
    -Xms5g：设置JVM初始内存为5G。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。
    -Xmn2g：设置年轻代大小为2G。整个堆内存大小 = 年轻代大小 + 年老代大小 + 持久代大小 。持久代一般固定大小为64m，所以增
    大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。
    -XX:+UseParNewGC：设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设
    置此值。
    -XX:ParallelGCThreads=8：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。
    -XX:SurvivorRatio=6：设置年轻代中Eden区与Survivor区的大小比值。根据经验设置为6，则两个Survivor区与一个Eden区的比值为
    2:6，一个Survivor区占整个年轻代的1/8。
    -XX:MaxTenuringThreshold=30： 设置垃圾最大年龄（次数）。如果设置为0的话，则年轻代对象不经过Survivor区直接进入年老代。
    对于年老代比较多的应用，可以提高效率。如果将此值 设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可
    以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。设置为30表示 一个对象如果在Survivor空间移动30次还没有被
    回收就放入年老代。
    -XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试配置这个参数以后，参数-XX:NewRatio=4就失效了，所以，此时年轻代
    大小最好用-Xmn设置，因此这个参数不建议使用。

    /usr/sbin/tomcat ##运行文件
    /etc/tomcat  ##配置文件
    /usr/libexec/tomcat
    /usr/share/tomcat ##目录文件 webapps

    ab -n 100 -c 10 http://192.168.1.104:8080/  10个用户发起100次请求 测试
	--------------------------------------

	-----消息队列-------------------------
	rabbitMQ:

	    exchange四种类型：topic /订阅发布  fanout：广播 direct：点对点 header：头信息匹配

        Broker：简单来说就是消息队列服务器实体。
        　　Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列。
        　　Queue：消息队列载体，每个消息都会被投入到一个或多个队列。
        　　Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。
        　　Routing Key：路由关键字，exchange根据这个关键字进行消息投递。
        　　vhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。
        　　producer：消息生产者，就是投递消息的程序。
        　　consumer：消息消费者，就是接受消息的程序。
        　　channel：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。
        消息队列的使用过程大概如下：
        （1）客户端连接到消息队列服务器，打开一个channel。
    　　（2）客户端声明一个exchange，并设置相关属性。
    　　（3）客户端声明一个queue，并设置相关属性。
    　　（4）客户端使用routing key，在exchange和queue之间建立好绑定关系。
    　　（5）客户端投递消息到exchange。
        exchange接收到消息后，就根据消息的key和已经设置的binding，进行消息路由，将消息投递到一个或多个队列里。
        exchange也有几个类型，完全根据key进行投递的叫做Direct交换机，例如，绑定时设置了routing key为”abc”，那么客户端提交的消息，只有设置了key为”abc”的才会投递到队列。对key进行模式匹配后进行投递的叫做Topic交换机，符号”#”匹配一个或多个词，符号”*”匹配正好一个词。例如”abc.#”匹配”abc.def.ghi”，”abc.*”只匹配”abc.def”。还有一种不需要key的，叫做Fanout交换机，它采取广播模式，一个消息进来时，投递到与该交换机绑定的所有队列。
        RabbitMQ支持消息的持久化，也就是数据写在磁盘上，为了数据安全考虑，我想大多数用户都会选择持久化。消息队列持久化包括3个部分：
        　　（1）exchange持久化，在声明时指定durable => 1
        　　（2）queue持久化，在声明时指定durable => 1
        　　（3）消息持久化，在投递时指定delivery_mode => 2（1是非持久化）
        如果exchange和queue都是持久化的，那么它们之间的binding也是持久化的。如果exchange和queue两者之间有一个持久化，一个非持久化，就不允许建立绑定。

    activeMQ:
        ⒈ 多种语言和协议编写客户端。语言: Java,C,C++,C#,Ruby,Perl,Python,PHP。应用协议： OpenWire,Stomp REST,WS Notification,XMPP,AMQP
        ⒉ 完全支持JMS1.1和J2EE 1.4规范 （持久化，XA消息，事务)
        ⒊ 对Spring的支持，ActiveMQ可以很容易内嵌到使用Spring的系统里面去，而且也支持Spring2.0的特性
        ⒋ 通过了常见J2EE服务器（如 Geronimo,JBoss 4,GlassFish,WebLogic)的测试，其中通过JCA 1.5 resource adaptors的配置，可以让ActiveMQ可以自动的部署到任何兼容J2EE 1.4 商业服务器上
        ⒌ 支持多种传送协议：in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA
        ⒍ 支持通过JDBC和journal提供高速的消息持久化
        ⒎ 从设计上保证了高性能的集群，客户端-服务器，点对点
        ⒏ 支持Ajax
        ⒐ 支持与Axis的整合
        ⒑ 可以很容易的调用内嵌JMS provider，进行测试

    kafka:
        Kafka [1]  是一种高吞吐量 [2]  的分布式发布订阅消息系统，有如下特性：
        通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。
        高吞吐量 [2]  ：即使是非常普通的硬件Kafka也可以支持每秒数百万 [2]  的消息。
        支持通过Kafka服务器和消费机集群来分区消息。
        支持Hadoop并行数据加载。 [3]
        Broker
        Kafka集群包含一个或多个服务器，这种服务器被称为broker [5]
        Topic
        每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）
        Partition
        Partition是物理上的概念，每个Topic包含一个或多个Partition.
        Producer
        负责发布消息到Kafka broker
        Consumer
        消息消费者，向Kafka broker读取消息的客户端。
        Consumer Group
        每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。

---------------------------------------------------------------------------------------
22 分布式事务解法：[锁/配置中心/事务/监控]
    1 XA协议：
    数据库需要支持XA协议，一个系统操作多个数据库更新或者插入，通过事务操作及开源Atomikio。
    2 消息队列：MQ
    生产者/消费者模式，完成系统解耦,但数据一致性/实时性问题，结合业务场景规避。
    3 TCC:编程式事务解决方案----atomikos 论文
    try{ #预留资源}
    confirm:#确认提交；
    cancel()：#数据回滚。
--------------------------------------------------------------------------------
23  类加载器分为四类：启动类加载器、扩展类加载器、应用类加载器和自定义类加载器。
启动类加载器：它的作用是将JAVA_HOME/lib目录下的类加载到内存中。需要注意的是由于启动类加载器涉及到虚拟机本地的实现细节，开发人员将无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。
扩展类加载器：它是由Sun的ExtClassLoader实现的，它的作用是将JAVA_HOME/lib/ext目录下或由系统变量 java.ext.dir指定位置中的类加载到内存中，它可以由开发人员直接使用。
应用程序类加载器：它是由Sun的AppClassLoader实现的，它的作用是将classpath路径下指定的类加载到内存中。它也可以由开发人员使用。
自定义类加载器：自定义的类加载器继承自ClassLoader，并覆盖findClass方法，它的作用是将特殊用途的类加载到内存中。

加载字节码--》验证文件是否完整及规范--》准备，放到内存方法区--》初始化类信息，静态变量方法区--》创建对象--》卸载
同一个类加载器同一个类名不会重复加载，jsp修改后tomcat每次会创建一个新的类加载器。


































